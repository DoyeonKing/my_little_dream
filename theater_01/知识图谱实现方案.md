# 餐剧盒平台知识图谱实现方案

## 1. 概述

知识图谱是餐剧盒平台的核心功能之一，旨在构建一个完整的剧场文化知识网络，连接剧目、演员、术语、时间线等实体，为用户提供丰富的剧场文化知识服务。

## 2. 知识图谱架构设计

### 2.1 技术栈选择

#### 2.1.1 图数据库
- **主选**: Neo4j 5.x
- **备选**: ArangoDB 3.x
- **原因**: 
  - 支持复杂的图查询和路径分析
  - 提供丰富的图算法库
  - 支持ACID事务
  - 有完善的Cypher查询语言

#### 2.1.2 搜索引擎
- **Elasticsearch 8.x**
- **功能**: 全文搜索、模糊匹配、相关性排序

#### 2.1.3 缓存层
- **Redis 6.x**
- **功能**: 热点数据缓存、会话管理

### 2.2 系统架构

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   前端应用      │    │   API网关       │    │   业务服务      │
│  (Android App)  │◄──►│  (Kong/Nginx)   │◄──►│  (Spring Boot)  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
                                                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   图数据库      │    │   关系数据库    │    │   搜索引擎      │
│   (Neo4j)       │◄──►│  (PostgreSQL)   │◄──►│ (Elasticsearch) │
└─────────────────┘    └─────────────────┘    └─────────────────┘
                                                       │
                                                       ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   缓存层        │    │   文件存储      │    │   AI服务        │
│   (Redis)       │◄──►│  (MinIO/S3)     │◄──►│  (OpenAI/本地)  │
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

## 3. 知识图谱数据模型

### 3.1 实体类型定义

#### 3.1.1 核心实体
```cypher
// 剧目实体
(:Play {
    id: String,
    title: String,
    originalTitle: String,
    category: String,
    description: String,
    plotSummary: String,
    author: String,
    director: String,
    composer: String,
    year: Integer,
    durationMinutes: Integer,
    language: String,
    rating: Float,
    viewCount: Integer,
    tags: [String],
    posterUrl: String,
    trailerUrl: String,
    createdAt: DateTime,
    updatedAt: DateTime
})

// 演员实体
(:Actor {
    id: String,
    name: String,
    englishName: String,
    role: String,
    description: String,
    personalBio: String,
    birthYear: Integer,
    nationality: String,
    height: Integer,
    weight: Integer,
    rating: Float,
    workCount: Integer,
    isVerified: Boolean,
    avatarUrl: String,
    createdAt: DateTime,
    updatedAt: DateTime
})

// 角色实体
(:Character {
    id: String,
    name: String,
    description: String,
    characterType: String,
    importanceLevel: Integer,
    createdAt: DateTime
})

// 术语实体
(:Terminology {
    id: String,
    term: String,
    category: String,
    description: String,
    detailedDescription: String,
    usageExamples: [String],
    relatedTerms: [String],
    viewCount: Integer,
    createdAt: DateTime,
    updatedAt: DateTime
})

// 剧场实体
(:Theater {
    id: String,
    name: String,
    englishName: String,
    description: String,
    address: String,
    city: String,
    province: String,
    country: String,
    latitude: Float,
    longitude: Float,
    capacity: Integer,
    createdAt: DateTime,
    updatedAt: DateTime
})

// 时间线事件实体
(:TimelineEvent {
    id: String,
    title: String,
    description: String,
    eventDate: Date,
    eventType: String,
    importanceLevel: Integer,
    createdAt: DateTime
})
```

#### 3.1.2 关系类型定义
```cypher
// 剧目相关关系
(:Play)-[:HAS_CHARACTER]->(:Character)
(:Play)-[:PERFORMED_AT]->(:Theater)
(:Play)-[:SIMILAR_TO]->(:Play)
(:Play)-[:INFLUENCED_BY]->(:Play)
(:Play)-[:ADAPTED_FROM]->(:Play)

// 演员相关关系
(:Actor)-[:PLAYS_CHARACTER]->(:Character)
(:Actor)-[:PERFORMS_IN]->(:Play)
(:Actor)-[:COLLABORATED_WITH]->(:Actor)
(:Actor)-[:MENTORED]->(:Actor)
(:Actor)-[:AWARDED]->(:Award)

// 角色相关关系
(:Character)-[:APPEARS_IN]->(:Play)
(:Character)-[:RELATED_TO]->(:Character)
(:Character)-[:OPPOSES]->(:Character)

// 术语相关关系
(:Terminology)-[:RELATED_TO]->(:Terminology)
(:Terminology)-[:USED_IN]->(:Play)
(:Terminology)-[:APPLIES_TO]->(:Actor)

// 时间线关系
(:TimelineEvent)-[:HAPPENED_TO]->(:Actor|Play|Theater)
(:TimelineEvent)-[:LED_TO]->(:TimelineEvent)
(:TimelineEvent)-[:INFLUENCED]->(:TimelineEvent)
```

### 3.2 属性权重设计

#### 3.2.1 关系权重
```cypher
// 关系权重定义
[:PERFORMS_IN {weight: 1.0, frequency: Integer}]
[:PLAYS_CHARACTER {weight: 0.8, importance: Integer}]
[:COLLABORATED_WITH {weight: 0.6, collaborationCount: Integer}]
[:SIMILAR_TO {weight: 0.7, similarityScore: Float}]
[:RELATED_TO {weight: 0.5, relevanceScore: Float}]
```

#### 3.2.2 实体重要性评分
```cypher
// 实体重要性计算公式
importance = (rating * 0.3) + (viewCount * 0.2) + (workCount * 0.2) + (awardCount * 0.3)
```

## 4. 知识图谱构建流程

### 4.1 数据采集策略

#### 4.1.1 数据来源
- **官方数据**: 剧场官网、演出公司官网
- **用户生成内容**: 用户评论、剧评、分享
- **第三方数据**: 维基百科、豆瓣、IMDb
- **专业资料**: 戏剧学院资料、专业期刊

#### 4.1.2 数据采集方法
```python
# 数据采集示例代码
class TheaterDataCollector:
    def collect_play_data(self, play_id):
        # 从多个数据源收集剧目信息
        sources = [
            self.collect_from_official_site(play_id),
            self.collect_from_wikipedia(play_id),
            self.collect_from_user_reviews(play_id)
        ]
        return self.merge_and_validate_data(sources)
    
    def collect_actor_data(self, actor_id):
        # 收集演员信息
        pass
    
    def collect_terminology_data(self):
        # 收集专业术语
        pass
```

### 4.2 数据预处理

#### 4.2.1 数据清洗
```python
class DataCleaner:
    def clean_text(self, text):
        # 去除HTML标签
        text = re.sub(r'<[^>]+>', '', text)
        # 去除特殊字符
        text = re.sub(r'[^\w\s\u4e00-\u9fff]', '', text)
        # 标准化格式
        return text.strip()
    
    def normalize_entity_name(self, name):
        # 实体名称标准化
        name = name.strip()
        # 去除多余空格
        name = re.sub(r'\s+', ' ', name)
        return name
    
    def extract_entities(self, text):
        # 实体识别和提取
        entities = []
        # 使用NER模型识别实体
        return entities
```

#### 4.2.2 实体链接
```python
class EntityLinker:
    def link_entities(self, text, entities):
        # 实体链接算法
        linked_entities = []
        for entity in entities:
            # 查找知识图谱中的匹配实体
            matched_entity = self.find_matching_entity(entity)
            if matched_entity:
                linked_entities.append({
                    'entity': entity,
                    'linked_to': matched_entity,
                    'confidence': self.calculate_confidence(entity, matched_entity)
                })
        return linked_entities
```

### 4.3 知识图谱构建

#### 4.3.1 图数据库操作
```cypher
// 创建剧目节点
CREATE (p:Play {
    id: $playId,
    title: $title,
    category: $category,
    description: $description,
    rating: $rating,
    viewCount: $viewCount,
    tags: $tags,
    createdAt: datetime()
})

// 创建演员节点
CREATE (a:Actor {
    id: $actorId,
    name: $name,
    role: $role,
    description: $description,
    rating: $rating,
    isVerified: $isVerified,
    createdAt: datetime()
})

// 创建关系
MATCH (a:Actor {id: $actorId})
MATCH (p:Play {id: $playId})
CREATE (a)-[:PERFORMS_IN {weight: 1.0, createdAt: datetime()}]->(p)
```

#### 4.3.2 批量导入
```python
class GraphImporter:
    def import_plays(self, plays_data):
        with self.driver.session() as session:
            for play in plays_data:
                session.run("""
                    CREATE (p:Play {
                        id: $id,
                        title: $title,
                        category: $category,
                        description: $description,
                        rating: $rating,
                        viewCount: $viewCount,
                        tags: $tags,
                        createdAt: datetime()
                    })
                """, play)
    
    def import_relationships(self, relationships_data):
        with self.driver.session() as session:
            for rel in relationships_data:
                session.run("""
                    MATCH (a:Actor {id: $actorId})
                    MATCH (p:Play {id: $playId})
                    CREATE (a)-[:PERFORMS_IN {weight: $weight}]->(p)
                """, rel)
```

## 5. 知识图谱查询服务

### 5.1 基础查询服务

#### 5.1.1 实体查询
```cypher
// 查询剧目信息
MATCH (p:Play {id: $playId})
OPTIONAL MATCH (p)-[:HAS_CHARACTER]->(c:Character)
OPTIONAL MATCH (a:Actor)-[:PLAYS_CHARACTER]->(c)
RETURN p, collect(DISTINCT c) as characters, 
       collect(DISTINCT a) as actors

// 查询演员信息
MATCH (a:Actor {id: $actorId})
OPTIONAL MATCH (a)-[:PERFORMS_IN]->(p:Play)
OPTIONAL MATCH (a)-[:PLAYS_CHARACTER]->(c:Character)
RETURN a, collect(DISTINCT p) as plays, 
       collect(DISTINCT c) as characters

// 查询术语信息
MATCH (t:Terminology {id: $termId})
OPTIONAL MATCH (t)-[:RELATED_TO]->(rt:Terminology)
OPTIONAL MATCH (t)-[:USED_IN]->(p:Play)
RETURN t, collect(DISTINCT rt) as relatedTerms, 
       collect(DISTINCT p) as relatedPlays
```

#### 5.1.2 关系查询
```cypher
// 查询演员合作关系
MATCH (a1:Actor)-[:PERFORMS_IN]->(p:Play)<-[:PERFORMS_IN]-(a2:Actor)
WHERE a1.id = $actorId AND a1 <> a2
RETURN a2, count(p) as collaborationCount
ORDER BY collaborationCount DESC

// 查询相似剧目
MATCH (p1:Play {id: $playId})
MATCH (p2:Play)
WHERE p1 <> p2
WITH p1, p2, 
     gds.similarity.cosine(p1.tags, p2.tags) as similarity
WHERE similarity > 0.5
RETURN p2, similarity
ORDER BY similarity DESC
LIMIT 10
```

### 5.2 高级查询服务

#### 5.2.1 路径查询
```cypher
// 查询两个演员之间的关联路径
MATCH path = (a1:Actor {id: $actorId1})-[*1..3]-(a2:Actor {id: $actorId2})
RETURN path, length(path) as pathLength
ORDER BY pathLength
LIMIT 5

// 查询剧目影响链
MATCH path = (p1:Play {id: $playId})-[*1..5]->(p2:Play)
WHERE ALL(rel IN relationships(path) WHERE type(rel) IN ['INFLUENCED_BY', 'ADAPTED_FROM'])
RETURN path
ORDER BY length(path)
```

#### 5.2.2 推荐查询
```cypher
// 基于协同过滤的剧目推荐
MATCH (u:User {id: $userId})-[:LIKES]->(p1:Play)
MATCH (p1)-[:SIMILAR_TO]->(p2:Play)
WHERE NOT (u)-[:LIKES]->(p2)
RETURN p2, count(p1) as recommendationScore
ORDER BY recommendationScore DESC
LIMIT 10

// 基于内容的演员推荐
MATCH (a1:Actor {id: $actorId})
MATCH (a2:Actor)
WHERE a1 <> a2
WITH a1, a2, 
     gds.similarity.cosine(a1.specialties, a2.specialties) as similarity
WHERE similarity > 0.6
RETURN a2, similarity
ORDER BY similarity DESC
LIMIT 10
```

## 6. 智能问答服务

### 6.1 问题理解
```python
class QuestionAnalyzer:
    def analyze_question(self, question):
        # 问题类型识别
        question_types = {
            'entity_info': r'(.*)的信息|(.*)的资料|(.*)的简介',
            'relationship': r'(.*)和(.*)的关系|(.*)与(.*)的关联',
            'recommendation': r'推荐(.*)|建议(.*)|类似(.*)',
            'timeline': r'(.*)的时间线|(.*)的发展历程',
            'comparison': r'(.*)和(.*)的区别|(.*)与(.*)的对比'
        }
        
        for qtype, pattern in question_types.items():
            if re.match(pattern, question):
                return qtype, re.match(pattern, question).groups()
        
        return 'general', None
```

### 6.2 查询生成
```python
class QueryGenerator:
    def generate_query(self, question_type, entities):
        if question_type == 'entity_info':
            return self.generate_entity_query(entities)
        elif question_type == 'relationship':
            return self.generate_relationship_query(entities)
        elif question_type == 'recommendation':
            return self.generate_recommendation_query(entities)
        # ... 其他类型
    
    def generate_entity_query(self, entities):
        entity_name = entities[0]
        return f"""
        MATCH (e)
        WHERE e.name CONTAINS '{entity_name}' OR e.title CONTAINS '{entity_name}'
        RETURN e
        LIMIT 1
        """
```

### 6.3 答案生成
```python
class AnswerGenerator:
    def generate_answer(self, query_result, question_type):
        if question_type == 'entity_info':
            return self.format_entity_info(query_result)
        elif question_type == 'relationship':
            return self.format_relationship_info(query_result)
        # ... 其他类型
    
    def format_entity_info(self, entity):
        if entity['type'] == 'Play':
            return f"{entity['title']}是一部{entity['category']}，由{entity['author']}创作。{entity['description']}"
        elif entity['type'] == 'Actor':
            return f"{entity['name']}是一位{entity['role']}演员，{entity['description']}"
```

## 7. 知识图谱可视化

### 7.1 前端可视化组件

#### 7.1.1 图可视化库
```javascript
// 使用D3.js或Vis.js进行图可视化
class KnowledgeGraphVisualizer {
    constructor(container) {
        this.container = container;
        this.network = null;
        this.init();
    }
    
    init() {
        const options = {
            nodes: {
                shape: 'dot',
                size: 16,
                font: {
                    size: 12,
                    face: 'Arial'
                },
                borderWidth: 2,
                shadow: true
            },
            edges: {
                width: 2,
                shadow: true,
                smooth: {
                    type: 'continuous'
                }
            },
            physics: {
                stabilization: false,
                barnesHut: {
                    gravitationalConstant: -80000,
                    springConstant: 0.001,
                    springLength: 200
                }
            }
        };
        
        this.network = new vis.Network(this.container, this.data, options);
    }
    
    updateData(data) {
        this.data = data;
        this.network.setData(data);
    }
}
```

### 7.2 移动端适配

#### 7.2.1 响应式设计
```kotlin
@Composable
fun KnowledgeGraphView(
    modifier: Modifier = Modifier,
    graphData: GraphData,
    onNodeClick: (String) -> Unit
) {
    var selectedNode by remember { mutableStateOf<String?>(null) }
    
    Box(modifier = modifier.fillMaxSize()) {
        // 图可视化组件
        AndroidView(
            factory = { context ->
                GraphView(context).apply {
                    setOnNodeClickListener { nodeId ->
                        selectedNode = nodeId
                        onNodeClick(nodeId)
                    }
                }
            },
            update = { view ->
                view.updateData(graphData)
            }
        )
        
        // 节点详情面板
        selectedNode?.let { nodeId ->
            NodeDetailsPanel(
                nodeId = nodeId,
                onDismiss = { selectedNode = null }
            )
        }
    }
}
```

## 8. 性能优化

### 8.1 查询优化

#### 8.1.1 索引优化
```cypher
// 创建索引
CREATE INDEX play_title_index FOR (p:Play) ON (p.title)
CREATE INDEX actor_name_index FOR (a:Actor) ON (a.name)
CREATE INDEX terminology_term_index FOR (t:Terminology) ON (t.term)

// 创建全文搜索索引
CREATE FULLTEXT INDEX play_search_index FOR (p:Play) ON EACH [p.title, p.description]
CREATE FULLTEXT INDEX actor_search_index FOR (a:Actor) ON EACH [a.name, a.description]
```

#### 8.1.2 查询缓存
```python
class QueryCache:
    def __init__(self):
        self.redis_client = redis.Redis()
        self.cache_ttl = 3600  # 1小时
    
    def get_cached_result(self, query_hash):
        cached = self.redis_client.get(f"query:{query_hash}")
        return json.loads(cached) if cached else None
    
    def cache_result(self, query_hash, result):
        self.redis_client.setex(
            f"query:{query_hash}",
            self.cache_ttl,
            json.dumps(result)
        )
    
    def execute_with_cache(self, query, params):
        query_hash = hashlib.md5(f"{query}{params}".encode()).hexdigest()
        
        # 尝试从缓存获取
        cached_result = self.get_cached_result(query_hash)
        if cached_result:
            return cached_result
        
        # 执行查询
        result = self.execute_query(query, params)
        
        # 缓存结果
        self.cache_result(query_hash, result)
        
        return result
```

### 8.2 存储优化

#### 8.2.1 数据分区
```cypher
// 按类别分区
CREATE INDEX play_category_index FOR (p:Play) ON (p.category)
CREATE INDEX actor_role_index FOR (a:Actor) ON (a.role)

// 按时间分区
CREATE INDEX play_year_index FOR (p:Play) ON (p.year)
CREATE INDEX actor_birth_year_index FOR (a:Actor) ON (a.birthYear)
```

#### 8.2.2 数据压缩
```python
class DataCompressor:
    def compress_entity_data(self, entity):
        # 压缩实体数据
        compressed = {
            'id': entity['id'],
            'type': entity['type'],
            'props': self.compress_properties(entity['properties'])
        }
        return compressed
    
    def compress_properties(self, properties):
        # 压缩属性数据
        compressed = {}
        for key, value in properties.items():
            if isinstance(value, str) and len(value) > 100:
                compressed[key] = self.compress_text(value)
            else:
                compressed[key] = value
        return compressed
```

## 9. 监控与维护

### 9.1 性能监控

#### 9.1.1 查询性能监控
```python
class QueryMonitor:
    def __init__(self):
        self.metrics = defaultdict(list)
    
    def monitor_query(self, query, params, execution_time):
        self.metrics['query_times'].append(execution_time)
        self.metrics['query_count'] += 1
        
        if execution_time > 1.0:  # 超过1秒的慢查询
            self.log_slow_query(query, params, execution_time)
    
    def get_performance_stats(self):
        times = self.metrics['query_times']
        return {
            'avg_time': sum(times) / len(times),
            'max_time': max(times),
            'min_time': min(times),
            'total_queries': self.metrics['query_count']
        }
```

#### 9.1.2 图数据库健康检查
```python
class GraphHealthChecker:
    def check_graph_health(self):
        health_status = {
            'node_count': self.get_node_count(),
            'relationship_count': self.get_relationship_count(),
            'index_status': self.check_indexes(),
            'memory_usage': self.get_memory_usage(),
            'disk_usage': self.get_disk_usage()
        }
        
        return health_status
    
    def get_node_count(self):
        with self.driver.session() as session:
            result = session.run("MATCH (n) RETURN count(n) as count")
            return result.single()['count']
```

### 9.2 数据质量监控

#### 9.2.1 数据完整性检查
```python
class DataQualityChecker:
    def check_data_integrity(self):
        issues = []
        
        # 检查孤立节点
        isolated_nodes = self.find_isolated_nodes()
        if isolated_nodes:
            issues.append(f"发现{len(isolated_nodes)}个孤立节点")
        
        # 检查重复实体
        duplicate_entities = self.find_duplicate_entities()
        if duplicate_entities:
            issues.append(f"发现{len(duplicate_entities)}个重复实体")
        
        # 检查关系完整性
        broken_relationships = self.find_broken_relationships()
        if broken_relationships:
            issues.append(f"发现{len(broken_relationships)}个断裂关系")
        
        return issues
    
    def find_isolated_nodes(self):
        with self.driver.session() as session:
            result = session.run("""
                MATCH (n)
                WHERE NOT (n)--()
                RETURN n
            """)
            return [record['n'] for record in result]
```

## 10. 部署方案

### 10.1 容器化部署

#### 10.1.1 Docker配置
```dockerfile
# Neo4j Dockerfile
FROM neo4j:5.0

# 安装插件
RUN wget -O /var/lib/neo4j/plugins/apoc.jar \
    https://github.com/neo4j/apoc/releases/download/5.0.0/apoc-5.0.0-core.jar

# 配置Neo4j
COPY neo4j.conf /var/lib/neo4j/conf/neo4j.conf

# 暴露端口
EXPOSE 7474 7687

# 启动Neo4j
CMD ["neo4j"]
```

#### 10.1.2 Docker Compose配置
```yaml
version: '3.8'
services:
  neo4j:
    image: neo4j:5.0
    container_name: theater_neo4j
    ports:
      - "7474:7474"
      - "7687:7687"
    environment:
      - NEO4J_AUTH=neo4j/password
      - NEO4J_PLUGINS=["apoc"]
    volumes:
      - neo4j_data:/data
      - neo4j_logs:/logs
      - neo4j_import:/import
      - neo4j_plugins:/plugins
  
  elasticsearch:
    image: elasticsearch:8.0.0
    container_name: theater_elasticsearch
    ports:
      - "9200:9200"
    environment:
      - discovery.type=single-node
      - xpack.security.enabled=false
    volumes:
      - elasticsearch_data:/usr/share/elasticsearch/data
  
  redis:
    image: redis:6.0
    container_name: theater_redis
    ports:
      - "6379:6379"
    volumes:
      - redis_data:/data

volumes:
  neo4j_data:
  neo4j_logs:
  neo4j_import:
  neo4j_plugins:
  elasticsearch_data:
  redis_data:
```

### 10.2 集群部署

#### 10.2.1 Neo4j集群配置
```yaml
# Neo4j集群配置
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: neo4j-cluster
spec:
  serviceName: neo4j
  replicas: 3
  selector:
    matchLabels:
      app: neo4j
  template:
    metadata:
      labels:
        app: neo4j
    spec:
      containers:
      - name: neo4j
        image: neo4j:5.0
        ports:
        - containerPort: 7474
        - containerPort: 7687
        env:
        - name: NEO4J_dbms_mode
          value: "CORE"
        - name: NEO4J_causal__clustering_initial__discovery__members
          value: "neo4j-0.neo4j:5000,neo4j-1.neo4j:5000,neo4j-2.neo4j:5000"
        - name: NEO4J_causal__clustering_discovery__advertised__address
          value: "$(POD_NAME).neo4j"
        - name: NEO4J_causal__clustering_transaction__advertised__address
          value: "$(POD_NAME).neo4j:6000"
        - name: NEO4J_causal__clustering_raft__advertised__address
          value: "$(POD_NAME).neo4j:7000"
```

## 11. 总结

知识图谱的实现是一个复杂的系统工程，需要综合考虑数据采集、存储、查询、可视化等多个方面。通过合理的技术选型、架构设计和优化策略，可以构建一个高效、可扩展的剧场知识图谱系统，为用户提供丰富的知识服务。

关键成功因素：
1. **数据质量**: 确保数据的准确性和完整性
2. **性能优化**: 通过索引、缓存等手段提升查询性能
3. **用户体验**: 提供直观的可视化界面和智能问答功能
4. **可扩展性**: 支持数据的持续更新和功能的扩展
5. **监控维护**: 建立完善的监控和维护机制

通过这个知识图谱系统，餐剧盒平台可以为用户提供更加丰富和智能的剧场文化服务，提升用户体验和平台价值。
